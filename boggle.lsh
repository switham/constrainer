#!/fs/local/bin/lsh
### boggle -- A Lakota program to play the game of Boggle.
# Steve Witham <sw@tiac.remove_this.net>

execute-file /fs/bin/prcol.cmn  {# print-in-columns library}


procedure boggle-help
    print To enter a square, type in four lines of four letters each,
    print    (LP)or just sixteen letters(RP).
    print Press return on an empty line to quit the game.
    print Type "*" to have the computer generate a board.
    print Type "**" to have the computer generate and play boards
    print    all by itself continuously.


global dictionary-files
set-list dictionary-files /usr/dict/words.boggle
global dictionary
set-list dictionary  {# clear if code is re-loaded}

procedure read-dictionary
   local word

   set-list dictionary
   for dictionary-file {all-of dictionary-files}
      if {file? (dictionary-file)}
         raw-print Reading dictionary (dictionary-file)...
         file-read-loop (dictionary-file) word
            append-to-list dictionary (word)
            cycle
         return
      else
         cycle
   print Couldn't find a dictionary to read!


global squares squares-string padded-squares
set-list squares 0 1 2 3 4 5 6 7 8 9 A B C D E F
set-string squares-string {all-of squares}
set-list padded-squares 0 1 2 3 . 4 5 6 7 . 8 9 A B . C D E F
global paths
set-list paths  {# clear if code is re-loaded}


global dice
begin-list dice
   cotumi erlytt hnmuiq ehtwvr aneaeg stytid ooajbb dlvrey
   afkfps tisseo suneei schoap ottwoa gehnew rnhlmz xielrd


global score-table
set-list score-table 0 0 1 1 2 3 5 11


procedure generate-board-string
   local die board-string faces i

   set-list faces
   for die {all-of dice}
      chars (die)
      set-list-index-to chars {+ {random 6} 1}
      append-to-list faces (chars)
      cycle
   set-string board-string
   do i 1 16
      set-list-index-to faces {+ {random {length-of-list faces}} 1}
      set-string board-string (board-string)(faces)
      set-list faces {left-part-of faces} {right-part-of faces}
      cycle
   return (board-string)


procedure print-board-string board-string
   local line

   for line {chop 4 8 12 (board-string)}
      print {separate (space)(space) {chars (line)}}
      cycle


procedure generate-paths
   local s others i trash j k l m n o

   set-list others . . . . . . {all-of padded-squares} . . . . . .
   for s {all-of padded-squares}
      local adjacent-(s)
      for i 1 2 3 6 8 11 12 13  {# Diagonals ARE allowed!}
         set-list-index-to others (i)
         if not {equal? (others) .}
            append-to-list adjacent-(s) (others)
         cycle
      assign others trash others
      cycle
   set-list paths
   for i {all-of squares}
      for j {all-of adjacent-(i)}
         for k {list-difference adjacent-(j) (i)}
            append-to-list paths (i)(j)(k)
            for l {list-difference adjacent-(k) (i) (j)}
               append-to-list paths (i)(j)(k)(l)
               for m {list-difference adjacent-(l) (i) (j) (k)}
                  append-to-list paths (i)(j)(k)(l)(m)
                  for n {list-difference adjacent-(m) (i) (j) (k) (l)}
                     append-to-list paths (i)(j)(k)(l)(m)(n)
                     for o {list-difference adjacent-(n) (i) (j) (k) (l) (m)}
                        append-to-list paths (i)(j)(k)(l)(m)(n)(o)
                        cycle
                     cycle
                  cycle
               cycle
            cycle
         cycle
      cycle


procedure setup-dictionary-and-paths
   if not {defined? (dictionary)}
      read-dictionary
   if not {defined? (paths)}
      print Generating paths...
      generate-paths


procedure find-solutions board-string
   local path words

   for path {all-of paths}
      append-to-list words {translate (squares-string) (board-string) (path)}
      cycle
   set-list words {sort {uniq {all-of words}}}
   return {intersection words dictionary}

   
procedure play-boggle
   local i line squares-string board-string path words

   setup-dictionary-and-paths
   loop
      :print Type in the square, return to quit, or ? for more options:
      set-list board-string
      while {< {length-of-string (board-string)} 16}
         raw-print >(space)
         read line
         if not {defined? (line)}
         or-if {equal-any-of? (line) ? * **}
	    set-string board-string
            escape

         set-string board-string (board-string)(line)
         cycle
      if not {defined? (line)}
         return

      if {equal? (line) **}
         play-boggle-alone
         return

      if {equal? (line) ?}
         boggle-help
         cycle

      if {equal? (line) *}
         generate-board-string
         print-board-string (generate-board-string)
         set-string board-string (generate-board-string)
      find-solutions (board-string)
      set-list words {all-of find-solutions}
      print Press return to see {length-of-list words} words...
      read line
      print-down-columns {all-of words}
      score-solutions {all-of words}
      print Score: (score-solutions)
      cycle


procedure score-solutions words
   local score word len

   set-string total-score 0
   for word {all-of words}
      set-string len {length-of-string (word)}
      if {> (len) 8}
         set-string len 8
      set-list-index-to score-table (len)
      set-string score {+ (score) (score-table)}
      cycle
   return (score)


procedure play-boggle-alone
   local score ngames

   setup-dictionary-and-paths
   set-string total-score 0
   set-string ngames 0
   set-string best-score 0
   set-string best-board
   loop
      generate-board-string
      print-board-string (generate-board-string)
      find-solutions (generate-board-string)
      print-down-columns {all-of find-solutions}
      score-solutions {all-of find-solutions}
      set-string total-score {+ (total-score) (score-solutions)}
      if {> (score-solutions) (best-score)}
         set-string best-board (generate-board-string)
         set-string best-score (score-solutions)
      increment ngames
      print Score: (score-solutions) Average: {/ (total-score) (ngames)}
      print Best board: (best-board) (LP)score: (best-score)(RP) 
      cycle


if {equal? {argument 1} -?}
   print-error Usage: boggle [-load | -alone]
   quit-returning 1

else if {equal? {argument 1} -alone}
   play-boggle-alone
else
   if not {equal? {argument 1} -load}
      play-boggle
